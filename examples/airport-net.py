# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: percent
#       format_version: '1.3'
#       jupytext_version: 1.7.1
#   kernelspec:
#     display_name: Python (rnode2vec)
#     language: python
#     name: rnode2vec
# ---

# %% [markdown]
# # About this notebook
# This notebook is a step-by-step demonstration of ``emlens`` package. As an example, we will analyze an embedding of a worldwide airport network generated by DeepWalk. See generte-embedding.py for how to generate the emebdding.
#
# Note that this demonstration is not comprehensive. Please see the docstring for full the desriptions of the api.

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy import sparse

# %%
# %load_ext autoreload
# %autoreload 2
import emlens

# %% [markdown]
# # Data

# %%
edge_table = pd.read_csv("../data/airportnet/edges.csv")
node_table = pd.read_csv("../data/airportnet/nodes.csv")
emb = np.loadtxt("../data/airportnet/emb.txt")

# %% [markdown]
# ### Construct the network used for generating this embedding

# %%
N = node_table.shape[0]
net = sparse.csr_matrix(
    (edge_table.weight, (edge_table.source, edge_table.target)), shape=(N, N)
)
deg = np.array(net.sum(axis=0)).reshape(-1)  # calculate the degree

# %% [markdown]
# # Step 1: Visualizing embedding space

# %%
# Project the emebdding space to 2d for visualization using the LDA
sx = emlens.LDASemAxis()
sx.fit(emb, node_table["region"].values)
xy = sx.transform(emb, dim=2)  # set dim =1 to get an axis

# %%
# Visualization
fig, ax = plt.subplots(figsize=(10, 10))
df = node_table.copy()
df["x"] = xy[:, 0]
df["y"] = xy[:, 1]
df["deg"] = deg
ax = sns.scatterplot(
    data=df, x="x", y="y", hue="region", size="deg", sizes=(10, 150), ax=ax
)
ax.legend(frameon=False)
sns.despine()

# %% [markdown]
# # Step 2: Calculate the correlation to node degree

# %%
rho = emlens.assortativity(emb, deg)

# %%
print("correlation to degree: %.3f" % rho)

# %% [markdown]
# # Step 3: Calculate the modularity

# %%
Qr = emlens.modularity(emb, node_table["region"].values)
Qc = emlens.modularity(emb, node_table["Country"].values)
Qrnd = emlens.modularity(emb, node_table["Country"].sample(frac=1).values)

# %%
print("Modularity (region): %.2f" % Qr)
print("Modularity (country): %.2f" % Qc)
print("Modularity (random): %.2f" % Qrnd)

# %% [markdown]
# # Step 4: Visualize group-wise similarity and distance

# %% [markdown]
# ### dot similarity

# %%
S, labels = emlens.pairwise_dot_sim(emb, node_table["region"])

# %%
S = pd.DataFrame(S, index=labels, columns=labels)
fig, ax = plt.subplots(figsize=(5, 4))
sns.heatmap(S, cmap="coolwarm", center=0, vmax=20, vmin=-10, ax=ax)

# %% [markdown]
# ### distance

# %%
S, labels = emlens.pairwise_distance(emb, node_table["region"])

# %%
S = pd.DataFrame(S, index=labels, columns=labels)
fig, ax = plt.subplots(figsize=(5, 4))
sns.heatmap(S, cmap="plasma", ax=ax)

# %% [markdown]
# # Step 5: Find the most dense subspace

# %%
density = emlens.estimate_pdf(target=emb, emb=emb)

# %%
df = node_table.copy()
df["density"] = density
df.sort_values(by="density", ascending=False).head(10)

# %% [markdown]
# # Step 6: Calculate radius of gyration (ROG) for each country
# ROG is the standard deviation of distance of embedding vectors from their center, capturing a spread of embedding vectors around the center.

# %%
rogs = []
node_table["id"] = np.arange(node_table.shape[0])
for label, df in node_table.groupby("Country"):
    if df.shape[0] <= 1:
        continue
    emb_by_region = emb[df.id, :]
    rog = emlens.rog(emb_by_region, metric="cos")
    rogs += [{"ROG": rog, "Country": label}]
rog_table = pd.DataFrame(rogs)

# %%
print("**** Countries with the highest ROG ****")
display(rog_table.sort_values(by="ROG", ascending=False).head(10))

print("**** Countries with the smallest ROG ****")
display(rog_table.sort_values(by="ROG", ascending=False).tail(10))
